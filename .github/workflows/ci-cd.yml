name: CI/CD Pipeline
on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  integration-checks:
    name: Static Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install Ansible/dprint/checkov dependencies
        run: |
          pip install ansible-core ansible-lint checkov      
          curl -fsSL https://dprint.dev/install.sh | sh
          echo "$HOME/.dprint/bin" >> $GITHUB_PATH

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v3
        with:
          tflint_version: latest

      - name: Code Formatting Check (dprint)
        run: dprint check

      - name: Compute Provisioning Terraform Validation
        working-directory: compute-provisioning
        run: |
         terraform fmt -check -recursive
         terraform init -backend=false
         terraform validate
         tflint --init
         tflint --recursive
         checkov --directory . --framework terraform --quiet --compact


      - name: Ansible Lint
        working-directory: compute-installation
        run: |
          if [ -f requirements.yml ]; then
            ansible-galaxy collection install -r requirements.yml || true
          fi
          ansible-lint .
          checkov --directory . --framework ansible --quiet --compact

  compute-provisioning:
    name: Compute Provisioning
    needs: integration-checks
    runs-on: ubuntu-latest
    outputs:
      inventory: ${{ steps.generate-inventory.outputs.inventory }}
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-provisioner
          ping: ${{ secrets.PM_IP }}

      - name: "Authenticate to Google Cloud"
        uses: "google-github-actions/auth@v2"
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Terraform Init
        working-directory: ./compute-provisioning
        run: terraform init
        env:
          TF_VAR_proxmox_api_url: https://${{ secrets.PM_IP }}:8006/
          TF_VAR_proxmox_user: ${{ secrets.PM_USER }}
          TF_VAR_proxmox_password: ${{ secrets.PM_PASSWORD }}

      - name: Terraform Apply
        working-directory: ./compute-provisioning
        run: terraform apply -auto-approve
        env:
          TF_VAR_vm_user: ${{ secrets.SSH_USERNAME }}
          TF_VAR_vm_password: ${{ secrets.SSH_PASSWORD }}
          TF_VAR_vm_ssh_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_proxmox_ssh_username: ${{ secrets.PROXMOX_SSH_USERNAME }}
          TF_VAR_proxmox_ssh_key: ${{ secrets.PROXMOX_SSH_KEY }}
          TF_VAR_proxmox_stellar_dc: ${{ secrets.PROXMOX_STELLAR_DC }}
          TF_VAR_gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_gcp_sa_key: ${{ secrets.GCP_SA_KEY }}

      - name: Generate Ansible Inventory
        id: generate-inventory
        working-directory: compute-provisioning
        shell: bash
        run: |
          # terraform output -json ansible_inventory | grep '^{' > ../tf_output.json
          # SSH_USER=$(jq -r '.username' ../tf_output.json)
          # SSH_PASS=$(jq -r '.password' ../tf_output.json)

          # # prepare header into a temporary inventory file
          # TMP_INV="$(mktemp)"
          # cat <<EOF > "$TMP_INV"
          # all:
          #   vars:
          #     ansible_user: "$SSH_USER"
          #     ansible_become_password: "$SSH_PASS"
          #     ansible_python_interpreter: "/usr/bin/python3.11"
          #     ansible_connect_timeout: 60
          #     control_plane_cluster_cert_root: "/tmp/cluster_certs"
          #   children:
          # EOF

          # # Generate inventory into the temp file
          # bash .github/scripts/generate-inventory.sh ../tf_output.json "$TMP_INV"

          # # Export inventory as step output (no persistent file)
          # echo "inventory<<EOF" >> "$GITHUB_OUTPUT"
          # cat "$TMP_INV" >> "$GITHUB_OUTPUT"
          # echo "EOF" >> "$GITHUB_OUTPUT"

          # # cleanup
          # rm -f "$TMP_INV" ../tf_output.json
